513.找树左下角的值
题目链接: https://leetcode.cn/problems/find-bottom-left-tree-value/
文章讲解/视频讲解: https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html

112. 路径总和 
113. 路径总和ii
题目链接: 
https://leetcode.cn/problems/path-sum/
https://leetcode.cn/problems/path-sum-ii/
文章讲解/视频讲解: https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html

106.从中序与后序遍历序列构造二叉树 
105.从前序与中序遍历序列构造二叉树
题目链接:

文章讲解/视频讲解: https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html

● 自己看到题目的第一想法：
513. 层序遍历，最后一层的第一个元素即树左下角的值
112. 前序遍历，累加到叶子结点与目标比较，不相等则回溯。
113. 同112，多两个数组，一个用来记录结果集，一共用来记录路径。
106. 复杂 难 不会！
105.

● 看完代码随想录之后的想法：
513. 层序遍历的迭代法很好理解，相较而言，递归法更难。目标是找到左下角的值。翻译一下就是找到最深的靠左的叶子结点，所以递归法的遍历顺序无论前中后序遍历，都是先左后右，所以都可以。
     1. 确定递归函数的参数和返回值: 参数:根结点，还有一个int型变量记录深度。不需要返回值。
     2. 确定终止条件: 遇到叶子结点时，要更新叶子结点的深度。
     3. 确定单层递归的逻辑: 在找到最大深度时，递归过程依然需要使用回溯。可以理解为找到待定最深叶子结点后就返回了，没有对depth进行操作，所以要在递归之后depth--。
112. 递归函数的另一个参数传入 count 并不是累加值，而是直接累减值。当遇到叶子结点判断是否为0则是否形成路径。
     1. 确定递归函数的参数和返回类型: 需要二叉树的根结点以及一个计数器，返回值是boolean，因为发现一条路径直接返回，不需要继续遍历。
     2. 确定终止条件: 遇到叶子结点且计数器==0 返回true，如果遇到叶子结点没有合适的路径则返回false。
     3. 确定单层递归的逻辑: 终止判断条件是叶子结点，所以递归过程中就不要让空结点进入递归。
113. 与112题思路基本一致。
106. 通过中序遍历和后序遍历的数组可得:
     1) 如果后序数组为空，即没有最后一个中的元素，所以是空树
     2) 后序数组的最后一个元素是相对中结点元素，最后一个元素是根结点元素
     3) 在中序数组中找到其位置(后序数组最后一个元素)作为切割点 分为左区间和右区间(左子树和右子树)
     4) 切割中序数组
     5) 根据中序数组中的左区间和右区间切割后序数组
     6) 递归处理左区间和右区间(左子树的左右子树，右子树的左右子树)
105. 

● 自己实现过程中遇到哪些困难或者错误：
513. 无
112. 递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：
如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）
113. 递归的时候不仅结点要回溯，记录的路径也要紧接着回溯。
106. 难点在于如何切割中序数组和后序数组。中序数组可以通过找到中结点元素，前面的就是左子树数组，后面就是右子树数组；后序数组要通过切割好的中序数组的左子树数组大小来切割。
     切割之后会出现4个区间，区间的开闭要注意统一：都坚持左闭右开。
105.
