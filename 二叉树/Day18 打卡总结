530.二叉搜索树的最小绝对差
题目链接: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/submissions/
文章讲解: https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html
视频讲解: https://www.bilibili.com/video/BV1DD4y11779

501.二叉搜索树中的众数
题目链接: https://leetcode.cn/problems/find-mode-in-binary-search-tree/
文章讲解: https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html
视频讲解: https://www.bilibili.com/video/BV1fD4y117gp

236. 二叉树的最近公共祖先
题目链接: 
文章讲解: https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html
视频讲解: https://www.bilibili.com/video/BV1jd4y1B7E2

● 自己看到题目的第一想法：
530. 中序遍历记录数组，一一做差得到最小绝对差。
501. 不管是不是二叉搜索树都通过map来实现记录元素和元素出现过的次数，key = 元素; value = 出现的次数。所以可以先遍历整棵树记录map，再根据value排序得到众数。
236.

● 看完代码随想录之后的想法：
530. 通过双指针(当前结点-之前结点)来实现，不需要另外开辟一个ArrayList空间。主要的逻辑点在于在中的逻辑中需要 pre = cur; 来保证上一个结点紧跟着当前结点。
501. 我的第一想法是无论什么树都可以实现。针对于二叉搜索树时会有更好的办法，因为其中序遍历是升序的。通过双指针来指向当前元素和上一个元素，通过全局变量count来记录当前元素出现过的次数.
     通过count和maxCount进行比较，如果相等就加入，如果count > maxCount 则更新 maxCount 并清空结果集，然后加入当前元素。只用遍历一遍就能得到结果集。
236.

● 自己实现过程中遇到哪些困难或者错误：
530. 迭代法中 while(cur != null || !stack.isEmpty()) 注意是 “||” 不是 “&&” ！！
501. 在暴力检索法中有太多不认识的方法 需要学习map的相关操作！
236.
