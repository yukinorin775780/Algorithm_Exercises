回溯是递归的副产品，只要有递归就会有回溯，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。
回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。

回溯算法能解决如下问题：
组合问题：N个数里面按一定规则找出k个数的集合
排列问题：N个数按一定规则全排列，有几种排列方式
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
棋盘问题：N皇后，解数独等等

回溯问题总结来说可以用回溯三部曲来分析回溯算法，并套入回溯法的模板：
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

组合问题: for循环横向遍历，递归纵向遍历，回溯不断调整结果集. 
剪枝精髓是: for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了。

组合总和（一）: 已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉. 剪枝的代码可以在for循环加上 i <= 9 - (k - path.size()) + 1 的限制.
组合总和（二）: 剪枝的代码 for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
组合总和（三）: 此题涉及到去重操作，去重分为“树枝去重”和“树层去重”。而本题是“树层去重”。
              可以看出在candidates[i] == candidates[i - 1]相同的情况下：
              used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
              used[i - 1] == false，说明同一树层candidates[i - 1]使用过

多个集合求组合: 因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而回溯算法：求组合问题 和回溯算法：求组合总和 都是是求同一个集合中的组合！
              如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入1 * #按键。
              其实本题不算难，但也处处是细节，还是要反复琢磨。

切割问题: 分割回文串
切割问题其实类似组合问题: 求解组合问题的思路来解决 切割问题本题就成功一大半
如何模拟那些切割线？
切割问题中递归如何终止？
在递归循环中如何截取子串？
如何判断回文？

子集问题（一）: 在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。
              本题其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。
        
子集问题（二）: 
