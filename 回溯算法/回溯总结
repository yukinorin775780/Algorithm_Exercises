回溯是递归的副产品，只要有递归就会有回溯，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。
回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。

回溯算法能解决如下问题：
组合问题：N个数里面按一定规则找出k个数的集合
排列问题：N个数按一定规则全排列，有几种排列方式
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
棋盘问题：N皇后，解数独等等

回溯问题总结来说可以用回溯三部曲来分析回溯算法，并套入回溯法的模板：
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

组合问题: for循环横向遍历，递归纵向遍历，回溯不断调整结果集. 
剪枝精髓是: for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了。

组合总和（一）: 已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉. 剪枝的代码可以在for循环加上 i <= 9 - (k - path.size()) + 1 的限制.
组合总和（二）: 剪枝的代码 for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
组合总和（三）: 此题涉及到去重操作，去重分为“树枝去重”和“树层去重”。而本题是“树层去重”。
              可以看出在candidates[i] == candidates[i - 1]相同的情况下：
              used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
              used[i - 1] == false，说明同一树层candidates[i - 1]使用过

多个集合求组合: 因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而回溯算法：求组合问题 和回溯算法：求组合总和 都是是求同一个集合中的组合！
              如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入1 * #按键。
              其实本题不算难，但也处处是细节，还是要反复琢磨。

切割问题: 分割回文串
切割问题其实类似组合问题: 求解组合问题的思路来解决 切割问题本题就成功一大半
如何模拟那些切割线？
切割问题中递归如何终止？
在递归循环中如何截取子串？
如何判断回文？

子集问题（一）: 在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。
              本题其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。
子集问题（二）: 上题的基础上增加了去重，思路和组合总和3中一致。

递增子序列: 本题和子集2像也不像！像的是都需要做去重操作，但是不像的是去重操作的不同。

排列问题（一）: 大家此时可以感受出排列问题的不同：1. 每层都是从0开始搜索而不是startIndex 2.需要used数组记录path里都放了哪些元素了
排列问题（二）: 这道题目神奇的地方就是used[i - 1] == false也可以，used[i - 1] == true也可以！可以清晰的看到使用(used[i - 1] == false)，即树层去重，效率更高！


性能分析
子集问题分析：
时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)
空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)

排列问题分析：
时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
空间复杂度：O(n)，和子集问题同理。

组合问题分析：
时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
空间复杂度：O(n)，和子集问题同理。

N皇后问题分析：
时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * .... * 1。
空间复杂度：O(n)，和子集问题同理。

解数独问题分析：
时间复杂度：O(9^m) , m是'.'的数目。
空间复杂度：O(n^2)，递归的深度是n^2
