20. 有效的括号
题目链接: https://leetcode.cn/problems/valid-parentheses/
文章讲解/视频讲解: https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html

1047. 删除字符串中的所有相邻重复项
题目链接: https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/
文章讲解/视频讲解: https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html

150. 逆波兰表达式求值
题目链接: https://leetcode.cn/problems/evaluate-reverse-polish-notation/
文章讲解/视频讲解: https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html

● 自己看到题目的第一想法：
20. 通过栈的结构来实现，因为记得在学计算机基础的某门课中就提到过计算机是如何时间计算功能的，其中就是用栈来实现。具体实现方法不知道。。
1047. 通过栈的结构来实现，遍历整个字符串，把每一个遍历过的元素按入栈，每次入栈前都要和栈顶元素进行比较，如果不相同则入栈，如果相同则弹出栈。遍历结束后栈中的元素即不重复的相邻元素。但是如果按顺序弹出栈的话顺序是相反的，需要反转整个字符串然后返回。
150. 通过栈的结构来实现，遍历整个字符串，如果碰到任意操作符就弹出两次，将两个值进行操作(后+-*/前)，将值入栈，重复操作到遍历结束。

● 看完代码随想录之后的想法：
20. 理清一共有三种不匹配的情况: 情况1) 字符串里左方向的括号多余了，所以不匹配。例如: "("[{}]()
                            情况2) 括号没有多余，但是括号的类型没有匹配上。例如: ("["{}"}")
                            情况3) 字符串里右方向的括号多余了，所以不匹配。例如: ([{}])"))"
    理清情况后，遇到左括号后，将相应的右括号放入栈中。直到遇到右括号后，查看栈顶元素，如果一致则弹出栈顶元素，如果不一致则不匹配，继续反复操作。如果遍历还没结束发现栈为空，则说明右括号多了不匹配；遍历结束后如果栈为空则匹配，不为空则不匹配。
1047. 思路是一致的。就是最后栈中元素不需要通过反转方法来调换顺序，而是通过字符串的加法顺序不同来实现反转。str = deque.pop() + str;
      另一种方法是不需要用栈的数据结构，而是把字符串当作栈来使用，好处是返回时直接返回字符串就行不需要其它操作。
150. 思路是一致的。

● 自己实现过程中遇到哪些困难或者错误：
20. 要注意if(deque.isEmpty() || deque.peek() != ch)判断条件顺序不能颠倒！
1047. 可以把字符串看成一个栈，通过指针top始终指向字符串的末尾即栈顶元素。
150. 要注意 "-" 和 “/” 的特殊处理。
