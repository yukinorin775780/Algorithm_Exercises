1049. 最后一块石头的重量 II
题目链接: https://leetcode.cn/problems/last-stone-weight-ii/
文章讲解: https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html
视频讲解: https://www.bilibili.com/video/BV14M411C7oV

494. 目标和
题目链接: https://leetcode.cn/problems/target-sum/
文章讲解: https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html
视频讲解: https://www.bilibili.com/video/BV1o8411j73x

474.一和零
题目链接: 
文章讲解: https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html
视频讲解: https://www.bilibili.com/video/BV1rW4y1x7ZQ

● 自己看到题目的第一想法：
1049. 不知道用背包问题怎么解决，但是按照贪心的思路的话，如果石头数是双数，那么就降序排序，按顺序一个个撞，如果是奇数，那么就想让最大的和最小的撞，然后再降序按顺序以一个个撞。
494. target是背包的重量，每一个值只有两个状态，一个是正一个是负。
474. 

● 看完代码随想录之后的想法：
1. 确定dp数组以及下标的含义: 
2. 确定递推公式: 
3. dp数组如何初始化: 
4. 确定遍历顺序: 
5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

1049. 把石头尽可能分成重量相似的两个部分，就和416.分割等和子集的思路基本一致了，唯一的区别是最后的判断有些出入。动规五部曲: 
      1. 确定dp数组以及下标的含义: dp[j] 背包容量为j所具有的最大价值/最大重量为dp[j]
      2. 确定递推公式: dp[j] = Math.max(dp[j], dp[j-weight[i]]+value[i]) -> dp[j] = Math.max(dp[j], dp[j-stone[i]]+stone[i])
      3. dp数组如何初始化: dp[0]=0;dp[非零下标]=0; 与416思路一致 
      还需要考虑 dp数组 的大小，背包问题数组的大小是背包的容量，本题中stones的个数最大值为30，stones的重量/价值最大值为1000，所以总重量最大为3000，分成两个部分就是1500，所以数组的大小应该为1501不会超过int的最大值
      4. 确定遍历顺序: 顺序遍历石头stone.length，倒序遍历背包j=target,j>=stone[i]
      5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。
494. 将集合分成两个子集，一个子集是加法(left)，一个子集是减法(right)，left + right = sum , left - right = target 
     -> left - (sum - left) = target -> left = (target + sum)/2 如果不能整除则说明此集合不能通过加减得到target。
     此时题目就变成了集合里的所有元素装满大小为left的容器有多少种方法 -> 背包问题: left是背包容量，集合就是物品。动规五部曲: 
     1. 确定dp数组以及下标的含义: dp[j] 装满背包容量为j的背包有dp[j]种方法 
     2. 确定递推公式: 举例: 已有 1 -> 有dp[4]种方法凑成dp[5]; 2 -> 有dp[3]种方法凑成dp[5]; 3 -> 有dp[2]种方法凑成dp[5]; 4 -> 有dp[1]种方法凑成dp[5]; 5 -> 有dp[0]种方法凑成dp[5]
     所以dp[5]=dp[4]+dp[3]+dp[2]+dp[1]+dp[0];
     -> dp[j] += dp[j-nums[i]]
     3. dp数组如何初始化: dp[0]=1 举例:[0,0,0,0,0],target=0时, dp[0]=1 所以要初始化为1,不要深究背包0的语言逻辑，要看题目的应用情况。
     4. 确定遍历顺序: 先顺序遍历物品，再倒序遍历背包容量. 
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。
474. 


● 自己实现过程中遇到哪些困难或者错误：
1049. 注意最后求出的dp[target]是一堆的重量，sum - dp[target]是另一堆的重量，返回的是要两个堆的差值，所以是sum - dp[target] - dp[target]
494. 416是给一个背包容量，能否装满背包；1049是给一个背包容量，能装多少装多少；494是给一个背包容量，有多少种方法可以装满背包。
474. 
