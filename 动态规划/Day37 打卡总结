1049. 最后一块石头的重量 II
题目链接: https://leetcode.cn/problems/last-stone-weight-ii/
文章讲解: https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html
视频讲解: https://www.bilibili.com/video/BV14M411C7oV

494. 目标和
题目链接: 
文章讲解: https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html
视频讲解: https://www.bilibili.com/video/BV1o8411j73x

474.一和零
题目链接: 
文章讲解: https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html
视频讲解: https://www.bilibili.com/video/BV1rW4y1x7ZQ

● 自己看到题目的第一想法：
1049. 不知道用背包问题怎么解决，但是按照贪心的思路的话，如果石头数是双数，那么就降序排序，按顺序一个个撞，如果是奇数，那么就想让最大的和最小的撞，然后再降序按顺序以一个个撞。
494. 
474. 

● 看完代码随想录之后的想法：
1. 确定dp数组以及下标的含义: 
2. 确定递推公式: 
3. dp数组如何初始化: 
4. 确定遍历顺序: 
5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

1049. 把石头尽可能分成重量相似的两个部分，就和416.分割等和子集的思路基本一致了，唯一的区别是最后的判断有些出入。动规五部曲: 
      1. 确定dp数组以及下标的含义: dp[j] 背包容量为j所具有的最大价值/最大重量为dp[j]
      2. 确定递推公式: dp[j] = Math.max(dp[j], dp[j-weight[i]]+value[i]) -> dp[j] = Math.max(dp[j], dp[j-stone[i]]+stone[i])
      3. dp数组如何初始化: dp[0]=0;dp[非零下标]=0; 与416思路一致 
      还需要考虑 dp数组 的大小，背包问题数组的大小是背包的容量，本题中stones的个数最大值为30，stones的重量/价值最大值为1000，所以总重量最大为3000，分成两个部分就是1500，所以数组的大小应该为1501不会超过int的最大值
      4. 确定遍历顺序: 顺序遍历石头stone.length，倒序遍历背包j=target,j>=stone[i]
      5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。
494. 
474. 


● 自己实现过程中遇到哪些困难或者错误：
1049. 注意最后求出的dp[target]是一堆的重量，sum - dp[target]是另一堆的重量，返回的是要两个堆的差值，所以是sum - dp[target] - dp[target]
494. 
474. 
