121. 买卖股票的最佳时机
题目链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/
文章讲解: https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html
视频讲解: https://www.bilibili.com/video/BV1Xe4y1u77q

122.买卖股票的最佳时机II
题目链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
文章讲解: https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html
视频讲解: https://www.bilibili.com/video/BV1D24y1Q7Ls

● 自己看到题目的第一想法：
121. 暴力搜索，因为只能买买一次，那么就可以让每个数字对前面的所有作差，取最大差值及最大收益。不出所料，超时。
122. 贪心算法章节做过一次，就是只要当天买和前一天对比有收益就让result加上收益。

● 看完代码随想录之后的想法：
121. 贪心的思路就是从左边开始找最小值，从右边开始找最大值，当i和j相遇时相减得到的就是最大利润。
    动规五部曲: 
    1. 确定dp数组以及下标的含义: 通过二维数组的第二个元素来表示股票的持有状态: dp[i][0]表示持有股票得到的最大收益; dp[i][1]表示不持有股票的到的最大收益。
    2. 确定递推公式: dp[i-1][0]: 第i-1天持有股票的最大收益, -prices[i]: 买入第i天的股票时的收益。 dp[i][0] = max(dp[i-1][0], -prices[i])
                   dp[i-1][1]: 第i-1天不持有人股票的最大收益，dp[i-1][0] + prices[i]: 第i天卖出股票的到的最大收益。 dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
    3. dp数组如何初始化: dp[0][0] = -prices[0]; dp[0][1] = 0
    4. 确定遍历顺序: 从左到右，因为递推公式表明后面状态依赖于前一天的状态。
    5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。  
122. 与121的区别在于买卖股票的次数。只能买一次时dp[i][0]即持有股票的最大收益是前一天持有的最大收益和当天购买的最大收益进行比较，如果当天购买的话那么就是0(现有收益)-prices[i]代表了最大收益
     但本题可以多次买卖，那么现有收益不一定是0，而是前一天不持有股票的最大收益及dp[i-1][1];所以递推公式应该是dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])

● 自己实现过程中遇到哪些困难或者错误：
121. 无
122. 无
