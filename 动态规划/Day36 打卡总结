01背包问题 二维
文章讲解: https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html
视频讲解：https://www.bilibili.com/video/BV1cg411g7Y6

01背包问题 一维
文章讲解: https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html
视频讲解：https://www.bilibili.com/video/BV1BU4y177kY

416. 分割等和子集
本题是 01背包的应用类题目
题目链接: https://leetcode.cn/problems/partition-equal-subset-sum/
文章讲解: https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html
视频讲解：https://www.bilibili.com/video/BV1rt4y1N7jE

● 自己看到题目的第一想法：
416. 没太明白和背包问题有啥关系？是需要两个背包吗？不明白...

● 看完代码随想录之后的想法：
01背包(二维)动规五部曲:
1. 确定dp数组以及下标的含义: dp[i][j] 下标[0,i]之间的物品任取放入容量为j的背包
2. 确定递推公式: 不放物品i dp[i-1][j]; 放物品i dp[i-1][j-weight[i]](不放物品i并减去物品i的容量此时所能放的最大价值的背包) + value[i] 
-> 所以 dp[i][j] = Math.max(dp[i-1][j]),dp[i-1][j-weight[i]]+value[i]]
3. dp数组如何初始化: 详见背包九讲pdf!!!! 简单的来说就是全部初始化为0，第一行符合条件的位置复制为value[0]
4. 确定遍历顺序: 两层for循环(物品和背包容量) 对于二维dp数组实现的01背包两层for循环顺序可以颠倒。
5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

01背包(一维)动规五部曲:
1. 确定dp数组以及下标的含义: dp[j] 容量为j的背包所能装的最大价值为dp[j]
2. 确定递推公式: dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);
3. dp数组如何初始化: dp[0] = 0; 非零下标时应该初始化成非负数里面的最小值即初始化成0，因为递推公式是取最大值.
4. 确定遍历顺序: 只能先顺序遍历物品，再倒序遍历背包。因为只有在倒序遍历的时候才能保证每一个物品只用了一次，顺序遍历时会导致物品使用多次！具体可以通过递推公式来推导。
5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

416. 把集合分成两个子集，每个子集的和就是原集合的一半，如果一个集合的和等于原集合和的一半，那么另一个集合的和也是原集合和的一半。
所以可以将此问题抽象为01背包问题。集合里的元素为物品，背包的容量为原集合和的一半。判断能不能装满这个背包。集合里的元素值既为其价值，也为其重量。
     动规五部曲: 
     1. 确定dp数组以及下标的含义: dp[j] 容量为j的背包所有的最大价值为dp[j]
     2. 确定递推公式: dp[j] = Math.max(dp[j], dp[j-weight[i]]+value[i]) -> dp[j] = Math.max(dp[j],dp[j-nums[i]] + nums[i]); 
     3. dp数组如何初始化: dp[0] = 0; dp[非零下标] = 0,因为递推公式是取最大值，所以初始化为非负整数的最小值即为0.
     4. 确定遍历顺序: 先顺序遍历物品(数组)，再倒序遍历背包容量(j=target;j>=nums[i])。
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

● 自己实现过程中遇到哪些困难或者错误：
01背包问题问题汇总:
1. 先用二维数组实现01背包问题，实现出来后再问两个for循环是否可以颠倒顺序？可以颠倒，因为由递推公式可知无论先遍历哪一个都不会影响得到的dp[i][j]
2. 再用一维数组实现01背包问题，再问两个for循环是否可以颠倒顺序？ 不可以颠倒，如果颠倒了，将倒序遍历背包容量的for循环放在上一层，那么每个dp[j]就只会放入一个物品，即：背包只放入了一个物品。
for循环为什么是从后向前遍历？为什么不可以从前向后遍历？ -> 从后向前遍历是为了保证物品i只被放入了一次
3. 为什么二维数组中不用从后向前遍历，用从前向后问题就可以了？ -> 因为二维数组的dp[i][j]都是通过上一层dp[i-1][j]计算而来的。

416. 无
