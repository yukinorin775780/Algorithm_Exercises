343. 整数拆分
题目链接: https://leetcode.cn/problems/integer-break/
文章讲解: https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html
视频讲解：https://www.bilibili.com/video/BV1Mg411q7YJ

96.不同的二叉搜索树
题目链接: 
文章讲解: https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html
视频讲解：https://www.bilibili.com/video/BV1eK411o7QA

● 自己看到题目的第一想法：
343. 整数拆分最好的结果应该是拆成多个相近的整数，这样得到的乘积最大，这有点像贪心的思路了...目前还没找到动态规划的思路！
96. 

● 看完代码随想录之后的想法：
343. 动规五部曲: 
     1. 确定dp数组以及下标的含义: dp[i] 对i进行拆分得到的最大乘积为dp[i]
     2. 确定递推公式: dp[i] = j * dp[i-j]
     3. dp数组如何初始化: dp[0]=0 dp[1]=0//初始化为0因为无意义，因为0乘任何数都是0，题目要求的是最大值，所以不影响最后的结果 dp[2]=1
     4. 确定遍历顺序: 从前向后遍历，i从3开始遍历 {j从1开始遍历 ;j<=i/2; dp[i] = Math.max(j*(i-j),j*dp[i-j],dp[i]]); }
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。
96. 动规五部曲: 
     1. 确定dp数组以及下标的含义: 
     2. 确定递推公式: 
     3. dp数组如何初始化: 
     4. 确定遍历顺序: 
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

● 自己实现过程中遇到哪些困难或者错误：
343. 为什么 j<=i/2 即为什么j遍历到i/2就行？ 因为我们不知道m(拆成了多少个数字)是多少，但可以明确的是 m>=2 ,所以既然 m>=2,那么最差也应该是拆成两个相同的数字时可能是最大值。
     所以对于内循环当循环到 j=i/2时说明是两个相同的数，此时是最差的最大值，没有必要往后遍历了。
96. 
