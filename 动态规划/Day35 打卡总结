343. 整数拆分
题目链接: https://leetcode.cn/problems/integer-break/
文章讲解: https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html
视频讲解：https://www.bilibili.com/video/BV1Mg411q7YJ

96.不同的二叉搜索树
题目链接: https://leetcode.cn/problems/unique-binary-search-trees/
文章讲解: https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html
视频讲解：https://www.bilibili.com/video/BV1eK411o7QA

● 自己看到题目的第一想法：
343. 整数拆分最好的结果应该是拆成多个相近的整数，这样得到的乘积最大，这有点像贪心的思路了...目前还没找到动态规划的思路！
96. 可以想像成把第n个结点插入n-1个结点的树有多少种方法，其中n-1结点的树内包含了组成n-1树的多少种方法。问题在于怎样找规律，我的想法是当n=3时是看它能插在n=2的位置有多少个

● 看完代码随想录之后的想法：
343. 动规五部曲: 
     1. 确定dp数组以及下标的含义: dp[i] 对i进行拆分得到的最大乘积为dp[i]
     2. 确定递推公式: dp[i] = j * dp[i-j]
     3. dp数组如何初始化: dp[0]=0 dp[1]=0//初始化为0因为无意义，因为0乘任何数都是0，题目要求的是最大值，所以不影响最后的结果 dp[2]=1
     4. 确定遍历顺序: 从前向后遍历，i从3开始遍历 {j从1开始遍历 ;j<=i/2; dp[i] = Math.max(j*(i-j),j*dp[i-j],dp[i]]); }
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。
96. 规律在于当 n=3 时，让 1 作为头节点时，1 的右子树的布局和 n=2 时是一致的；让 2 作为头节点时，布局同 n=1 是一致的；让 3 作为头节点时，3 的左子树布局和 n=2 是一致的。
    所以当 n=3 时情况总数量 = 头结点为1 + 头结点为2 + 头结点为3。 头结点为1 = 左子树0结点 * 右子树2结点；头结点为2 = 左子树1结点 * 右子树1结点；头结点为3 = 左子树2结点 * 右子树0结点。
    所以 dp[3]=dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0]
     动规五部曲: 
     1. 确定dp数组以及下标的含义: dp[i] 输入i有dp[i]种不同的二叉搜索树
     2. 确定递推公式: 以j为头结点，左子树中一定有j-1个结点(因为是二叉搜索树),右子树一定有i-j个结点，那么左子树有dp[j-1]种不同的二叉树，右子树有dp[i-j]种不同的二叉搜索树，此时以j为头结点有dp[j-1]*dp[i-j]种不同的二叉搜索树
     所以dp[i] += dp[j-1] * dp[i-j] ; 意味着j从1开始遍历一直遍历到i说明:从1开始做头结点有多少种树 一直累加到 从i做头结点有多少种树，最后得到的dp[i]就是有多少种二叉搜索树。
     3. dp数组如何初始化: dp[0] = 1; dp[1] = 1; dp[0]必须赋为1，因为上面的乘法算法中会出现dp[0] * dp[i-j]，所得值应该是dp[i-j]种树。
     4. 确定遍历顺序: 从小到大便利
     5. 打印dp数组(用于debug): 判断dp数组是否符合题目要求从而判断代码哪里出了问题。

● 自己实现过程中遇到哪些困难或者错误：
343. 为什么 j<=i/2 即为什么j遍历到i/2就行？ 因为我们不知道m(拆成了多少个数字)是多少，但可以明确的是 m>=2 ,所以既然 m>=2,那么最差也应该是拆成两个相同的数字时可能是最大值。
     所以对于内循环当循环到 j=i/2时说明是两个相同的数，此时是最差的最大值，没有必要往后遍历了。
96. 首先要得到本题规律，规律要通过n=3时跟n=1和n=2有什么关系。其次要得到递推的公式，此公式一般是
