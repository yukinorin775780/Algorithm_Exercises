28. 实现 strStr()
题目链接: https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
文章讲解/视频讲解: https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html

459.重复的子字符串
题目链接: https://leetcode.cn/problems/repeated-substring-pattern/
文章讲解/视频讲解: https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html

字符串总结

文章讲解: https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html

双指针回顾
文章讲解: https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html

● 自己看到题目的第一想法：
28. 两层for循环，第一层遍历haystack字符串，第二层遍历needle字符串。暴力的搜索，遇到不一样的就+1.时间复杂度是O(m+n)
459. 暴力搜索，枚举出所有的子串，判断每一个子串是否可以组成整个字符串，当然，肯定会超时。

● 看完代码随想录之后的想法：
28. KMP算法: 需要掌握1.初始化 2.处理前后缀不相同的情况 3.处理前后缀相同的情况 来实现KMP算法。
459. 解法1: 暴力解法并不会超时，两个for循环嵌套，外面的for循环是从起始位置开始搜索，所以只需要一个for循环就能遍历完整个字符串。时间复杂度为O(n^2)
     解法2: 移动匹配的思路: 任何一个由重复字串构成的字符串，它的前半部分和后半部分一定有一个相等的区间(前半部分和后半部分可以重复)。
     所以将字符串s + s , 去掉头后只要下一次出现s的地方不是s.length()即不是加上第二个s的起始位置，就说明有重复。
     解法3: KMP算法。 如果字符串是由重复字串构成的，那么它的最小重复单位就是它的最长相等前后缀不包含的部分。比如 s = abababab，最长相等前后缀是ababab，所以不包含的是ab即最小重复单位。
          
     
● 自己实现过程中遇到哪些困难或者错误：
28. 学习KMP算法的过程中首先要了解其出现的原因: 当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。避免全部从头来过重新遍历。
引入了前缀表、后缀和最长相等前后缀的概念，要掌握其概念以及前缀表是怎么来的。
459. 解法2理解移动匹配的思路！
     解法3而言要理解为什么最小重复单位是它的最长相等前后缀不包含的部分。
