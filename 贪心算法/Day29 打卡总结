1005.K次取反后最大化的数组和
题目链接: https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/
文章讲解: https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html
视频链接: https://www.bilibili.com/video/BV138411G7LY/

134. 加油站
题目链接: https://leetcode.cn/problems/gas-station/
文章讲解: https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html
视频链接: https://www.bilibili.com/video/BV1jA411r7WX/

135. 分发糖果
题目链接: https://leetcode.cn/problems/candy/
文章讲解: https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html
视频链接: https://www.bilibili.com/video/BV1ev4y1r7wN/

● 自己看到题目的第一想法：
1005. 对数组排序，对前k个数字取反后 因为可以多次选择同一个下标i，先把数组中为负数的数字取反后再次排序，然后将排序后的第一个数字反复取反，最后累加。
134. 没有想法...
135. 比较前一个小孩和当前小孩的rating值如果不一致就++。

● 看完代码随想录之后的想法：
1005. 跟我的思路一致。此题包含两次贪心策略，第一次是先对于绝对值最大的负数进行优先取反。第二次是如果数组里都是正数，对最小的正数进行取反。
      实现第一步贪心: 将数组进行用绝对值大小排序，遍历数组{如果nums[i] < 0 && k > 0 ，取反，k--} 第二步贪心: 如果k是奇数，对数组中的最小值即数组的最后一位进行取反。遍历数组取和。
134. 把题目想复杂了，题目的本意是跑一圈即(1->2->3->0->1)一个循环，而不是想跑到哪里就跑到哪里。思路是将gas[i] - cos[i]得到的是油箱里还有多少油，正数即还剩多少油，负数说明不够，还需要多少油
     所以就是遍历此数组，遇到负数就要从负数的下一站开始重新计数遍历，看看能不能跑完一圈。用curSum来记录经过的每一个加油站，如果curSum < 0 则说明之前的哪个加油站作为起始点油都是不够的！
     证明 区间和1 + 区间和2 < 0 ; 区间和2 > 0 那么 区间和1 一定 < 0，那么根据我们循环的逻辑区间和1的下一个做为起始点，所以不存在说 区间和1+区间和2<0时 存在某个区间使得区间和2>0。
     本题的贪心算法在于局部最优解是遇到负数后选择下一个站做为起始点才有可能可以走一个循环。全局最优就是找到了起点。
135. 需要同时考虑两边的情况下会顾此失彼，所以先考虑 
     1.右边的小孩比左边的小孩得分高: 遍历顺序是从左往右遍历，if(rating[i] > rating[i - 1]) candy[i] = candy[i-1] + 1; 
     2.左边的孩子比右边的孩子得分高: 遍历顺序要从右往左遍历！if(rating[i] > rating[i + 1]) candy[i] = Math.max(candy[i],candy[i+1] + 1);需要结合前一次比较得到的值取最大值。


● 自己实现过程中遇到哪些困难或者错误：
1005. 如果用绝对值进行排序的优点是不需要对数组进行多次的排序！
134. 无
135. 首先要分别考虑两种情况，考虑第二种情况的同时需要结合第一次情况的结果取大的那个值！！！
