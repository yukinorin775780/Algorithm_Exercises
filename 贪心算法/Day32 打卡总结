738.单调递增的数字
题目链接: https://leetcode.cn/problems/monotone-increasing-digits/
文章讲解: https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html
视频链接: https://www.bilibili.com/video/BV1Kv4y1x7tP/

968.监控二叉树 （可以跳过）
题目链接: https://leetcode.cn/problems/binary-tree-cameras/
文章讲解: https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html
视频链接: https://www.bilibili.com/video/BV1SA411U75i/

总结
文章讲解: https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html

● 自己看到题目的第一想法：
738. 暴力检索，每--后计算一下当前元素是否是单调递增的。时间复杂度是 n*m 肯定是超时。
968. 因为是要求最少的监控摄像头数量，那么就优先在既有父结点又有子结点的结点安装摄像头，那么优先来说就是每个叶子结点的父结点要一个摄像头。每一个根结点附近需要一个摄像头。

● 看完代码随想录之后的想法：
738. 当元素为两位数时，一旦发现不符合要求就需要将十位上的数-1处理，个位数需要取最大值。
     所以，按从右往左的顺序(因为如果是从左往右的话再遍历过程中可能需要修改遍历过的数字)遍历数字，不符合要求就将前一位数 -1且当前位置取最大值。
968. 因为一个摄像头可以兼顾上中下的结点，所以对于叶子结点来说，要在它的父结点安放一个摄像头才能充分利用到上中下的覆盖范围。所以整体思路就是遇到叶子结点在其父结点安放一个摄像头，每隔两个空结点放一个摄像头。
     所以需要我们从下往上遍历每个节点，所以肯定是用后序遍历。通过记录结点的状态来判断需不需要放摄像头。分为0.无覆盖 1.有摄像头 2.有覆盖；问题是怎么进行状态转移，也就是对每个结点的状态切换。
     1.左右子结点都是有覆盖 --> 其父结点就是无覆盖0
     2.左右子结点至少有一个是无覆盖 --> 其父结点一定有摄像头1
     3.左右子结点至少有一个有摄像头 --> 其父结点一定是有覆盖2
     4.如果遍历结束时根结点是无覆盖的状态时，需要给根结点+摄像头
     递归遍历二叉树时的终止条件是: 当前结点为空，返回 2 即有覆盖的状态(下面分析得到的结果)

● 自己实现过程中遇到哪些困难或者错误：
738. 为什么需要用flag记录位置而不是在判断完前一个位数比当前位数大时就进行修改: 举例说明 如果是 1000 时，只有遍历到 千位和百位时才会符合if条件，此时千位-1 变成 0，如果直接将当前元素改为9，此时得到的结果是999，与我们想要的不符合。应该得到的是999，所以应该是自当前位置向后所有的值都改为9.
     为什么flag要初始化为字符串的长度: 因为在第一次遍历字符串时有可能不会走if的逻辑，也就是说flag没有修改过。所以当要对flag之后的值进行赋值为9的操作时，如果flag初始化为0，则得到的就是9999...肯定不是我们想要的，所以要初始化为字符串长度，这样才会避免对原生字符串不必要的修改。
968. 遍历时会遇到空结点，应该返回什么状态给其父结点(可能是叶子结点)呢: 首先要明确此题的目的--尽可能让叶子结点的父结点放摄像头！所以如果空结点是有摄像头的状态时，那么它的父结点(可能是叶子结点)就一定被覆盖了，就没有必要在叶子结点的父结点放摄像头；如果空结点是无摄像头的状态，那么叶子结点就一定要放摄像头；所以空结点只能是有覆盖的状态，所以叶子结点的父结点才会需要一个摄像头。
     
